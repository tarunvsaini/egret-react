{"ast":null,"code":"/*\n * PinkySwear.js 2.2.2 - Minimalistic implementation of the Promises/A+ spec\n * \n * Public Domain. Use, modify and distribute it any way you like. No attribution required.\n *\n * NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\n *\n * PinkySwear is a very small implementation of the Promises/A+ specification. After compilation with the\n * Google Closure Compiler and gzipping it weighs less than 500 bytes. It is based on the implementation for \n * Minified.js and should be perfect for embedding. \n *\n *\n * PinkySwear has just three functions.\n *\n * To create a new promise in pending state, call pinkySwear():\n *         var promise = pinkySwear();\n *\n * The returned object has a Promises/A+ compatible then() implementation:\n *          promise.then(function(value) { alert(\"Success!\"); }, function(value) { alert(\"Failure!\"); });\n *\n *\n * The promise returned by pinkySwear() is a function. To fulfill the promise, call the function with true as first argument and\n * an optional array of values to pass to the then() handler. By putting more than one value in the array, you can pass more than one\n * value to the then() handlers. Here an example to fulfill a promsise, this time with only one argument: \n *         promise(true, [42]);\n *\n * When the promise has been rejected, call it with false. Again, there may be more than one argument for the then() handler:\n *         promise(true, [6, 6, 6]);\n *         \n * You can obtain the promise's current state by calling the function without arguments. It will be true if fulfilled,\n * false if rejected, and otherwise undefined.\n * \t\t   var state = promise(); \n * \n * https://github.com/timjansen/PinkySwear.js\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = factory();\n  } else {\n    root.pinkySwear = factory();\n  }\n})(this, function () {\n  var undef;\n\n  function isFunction(f) {\n    return typeof f == 'function';\n  }\n\n  function isObject(f) {\n    return typeof f == 'object';\n  }\n\n  function defer(callback) {\n    if (typeof setImmediate != 'undefined') setImmediate(callback);else if (typeof process != 'undefined' && process['nextTick']) process['nextTick'](callback);else setTimeout(callback, 0);\n  }\n\n  return function pinkySwear(extend) {\n    var state; // undefined/null = pending, true = fulfilled, false = rejected\n\n    var values = []; // an array of values as arguments for the then() handlers\n\n    var deferred = []; // functions to call when set() is invoked\n\n    var set = function set(newState, newValues) {\n      if (state == null && newState != null) {\n        state = newState;\n        values = newValues;\n        if (deferred.length) defer(function () {\n          for (var i = 0; i < deferred.length; i++) {\n            deferred[i]();\n          }\n        });\n      }\n\n      return state;\n    };\n\n    set['then'] = function (onFulfilled, onRejected) {\n      var promise2 = pinkySwear(extend);\n\n      var callCallbacks = function callCallbacks() {\n        try {\n          var f = state ? onFulfilled : onRejected;\n\n          if (isFunction(f)) {\n            var resolve = function resolve(x) {\n              var then,\n                  cbCalled = 0;\n\n              try {\n                if (x && (isObject(x) || isFunction(x)) && isFunction(then = x['then'])) {\n                  if (x === promise2) throw new TypeError();\n                  then['call'](x, function () {\n                    if (!cbCalled++) resolve.apply(undef, arguments);\n                  }, function (value) {\n                    if (!cbCalled++) promise2(false, [value]);\n                  });\n                } else promise2(true, arguments);\n              } catch (e) {\n                if (!cbCalled++) promise2(false, [e]);\n              }\n            };\n\n            resolve(f.apply(undef, values || []));\n          } else promise2(state, values);\n        } catch (e) {\n          promise2(false, [e]);\n        }\n      };\n\n      if (state != null) defer(callCallbacks);else deferred.push(callCallbacks);\n      return promise2;\n    };\n\n    if (extend) {\n      set = extend(set);\n    }\n\n    return set;\n  };\n});","map":null,"metadata":{},"sourceType":"script"}