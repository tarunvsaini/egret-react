{"ast":null,"code":"/*! qwest 4.5.0 (https://github.com/pyrsmk/qwest) */\nmodule.exports = function () {\n  var global = typeof window != 'undefined' ? window : self,\n      pinkyswear = require('pinkyswear'),\n      jparam = require('jquery-param'),\n      defaultOptions = {},\n      // Default response type for XDR in auto mode\n  defaultXdrResponseType = 'json',\n      // Default data type\n  defaultDataType = 'post',\n      // Variables for limit mechanism\n  _limit = null,\n      requests = 0,\n      request_stack = [],\n      // Get XMLHttpRequest object\n  getXHR = global.XMLHttpRequest ? function () {\n    return new global.XMLHttpRequest();\n  } : function () {\n    return new ActiveXObject('Microsoft.XMLHTTP');\n  },\n      // Guess XHR version\n  xhr2 = getXHR().responseType === '',\n      // Core function\n  qwest = function qwest(method, url, data, options, before) {\n    // Format\n    method = method.toUpperCase();\n    data = data === undefined ? null : data;\n    options = options || {};\n\n    for (var name in defaultOptions) {\n      if (!(name in options)) {\n        if (typeof defaultOptions[name] == 'object' && typeof options[name] == 'object') {\n          for (var name2 in defaultOptions[name]) {\n            options[name][name2] = defaultOptions[name][name2];\n          }\n        } else {\n          options[name] = defaultOptions[name];\n        }\n      }\n    } // Define variables\n\n\n    var nativeResponseParsing = false,\n        crossOrigin,\n        xhr,\n        xdr = false,\n        timeout,\n        aborted = false,\n        attempts = 0,\n        headers = {},\n        mimeTypes = {\n      text: '*/*',\n      xml: 'text/xml',\n      json: 'application/json',\n      post: 'application/x-www-form-urlencoded',\n      document: 'text/html'\n    },\n        accept = {\n      text: '*/*',\n      xml: 'application/xml; q=1.0, text/xml; q=0.8, */*; q=0.1',\n      json: 'application/json; q=1.0, text/*; q=0.8, */*; q=0.1'\n    },\n        i,\n        j,\n        response,\n        sending = false,\n        // Create the promise\n    promise = pinkyswear(function (pinky) {\n      pinky.abort = function () {\n        if (!aborted) {\n          if (xhr && xhr.readyState != 4) {\n            // https://stackoverflow.com/questions/7287706/ie-9-javascript-error-c00c023f\n            xhr.abort();\n          }\n\n          if (sending) {\n            --requests;\n            sending = false;\n          }\n\n          aborted = true;\n        }\n      };\n\n      pinky.send = function () {\n        // Prevent further send() calls\n        if (sending) {\n          return;\n        } // Reached request limit, get out!\n\n\n        if (requests == _limit) {\n          request_stack.push(pinky);\n          return;\n        } // Verify if the request has not been previously aborted\n\n\n        if (aborted) {\n          if (request_stack.length) {\n            request_stack.shift().send();\n          }\n\n          return;\n        } // The sending is running\n\n\n        ++requests;\n        sending = true; // Get XHR object\n\n        xhr = getXHR();\n\n        if (crossOrigin) {\n          if (!('withCredentials' in xhr) && global.XDomainRequest) {\n            xhr = new XDomainRequest(); // CORS with IE8/9\n\n            xdr = true;\n\n            if (method != 'GET' && method != 'POST') {\n              method = 'POST';\n            }\n          }\n        } // Open connection\n\n\n        if (xdr) {\n          xhr.open(method, url);\n        } else {\n          xhr.open(method, url, options.async, options.user, options.password);\n\n          if (xhr2 && options.async) {\n            xhr.withCredentials = options.withCredentials;\n          }\n        } // Set headers\n\n\n        if (!xdr) {\n          for (var i in headers) {\n            if (headers[i]) {\n              xhr.setRequestHeader(i, headers[i]);\n            }\n          }\n        } // Verify if the response type is supported by the current browser\n\n\n        if (xhr2 && options.responseType != 'auto') {\n          try {\n            xhr.responseType = options.responseType;\n            nativeResponseParsing = xhr.responseType == options.responseType;\n          } catch (e) {}\n        } // Plug response handler\n\n\n        if (xhr2 || xdr) {\n          xhr.onload = handleResponse;\n          xhr.onerror = handleError; // http://cypressnorth.com/programming/internet-explorer-aborting-ajax-requests-fixed/\n\n          if (xdr) {\n            xhr.onprogress = function () {};\n          }\n        } else {\n          xhr.onreadystatechange = function () {\n            if (xhr.readyState == 4) {\n              handleResponse();\n            }\n          };\n        } // Plug timeout\n\n\n        if (options.async) {\n          if ('timeout' in xhr) {\n            xhr.timeout = options.timeout;\n            xhr.ontimeout = handleTimeout;\n          } else {\n            timeout = setTimeout(handleTimeout, options.timeout);\n          }\n        } // http://cypressnorth.com/programming/internet-explorer-aborting-ajax-requests-fixed/\n        else if (xdr) {\n            xhr.ontimeout = function () {};\n          } // Override mime type to ensure the response is well parsed\n\n\n        if (options.responseType != 'auto' && 'overrideMimeType' in xhr) {\n          xhr.overrideMimeType(mimeTypes[options.responseType]);\n        } // Run 'before' callback\n\n\n        if (before) {\n          before(xhr);\n        } // Send request\n\n\n        if (xdr) {\n          // https://developer.mozilla.org/en-US/docs/Web/API/XDomainRequest\n          setTimeout(function () {\n            xhr.send(method != 'GET' ? data : null);\n          }, 0);\n        } else {\n          xhr.send(method != 'GET' ? data : null);\n        }\n      };\n\n      return pinky;\n    }),\n        // Handle the response\n    handleResponse = function handleResponse() {\n      var i, responseType; // Stop sending state\n\n      sending = false;\n      clearTimeout(timeout); // Launch next stacked request\n\n      if (request_stack.length) {\n        request_stack.shift().send();\n      } // Verify if the request has not been previously aborted\n\n\n      if (aborted) {\n        return;\n      } // Decrease the number of requests\n\n\n      --requests; // Handle response\n\n      try {\n        // Process response\n        if (nativeResponseParsing) {\n          if ('response' in xhr && xhr.response === null) {\n            throw 'The request response is empty';\n          }\n\n          response = xhr.response;\n        } else {\n          // Guess response type\n          responseType = options.responseType;\n\n          if (responseType == 'auto') {\n            if (xdr) {\n              responseType = defaultXdrResponseType;\n            } else {\n              var ct = xhr.getResponseHeader('Content-Type') || '';\n\n              if (ct.indexOf(mimeTypes.json) > -1) {\n                responseType = 'json';\n              } else if (ct.indexOf(mimeTypes.xml) > -1) {\n                responseType = 'xml';\n              } else {\n                responseType = 'text';\n              }\n            }\n          } // Handle response type\n\n\n          switch (responseType) {\n            case 'json':\n              if (xhr.responseText.length) {\n                try {\n                  if ('JSON' in global) {\n                    response = JSON.parse(xhr.responseText);\n                  } else {\n                    response = new Function('return (' + xhr.responseText + ')')();\n                  }\n                } catch (e) {\n                  throw \"Error while parsing JSON body : \" + e;\n                }\n              }\n\n              break;\n\n            case 'xml':\n              // Based on jQuery's parseXML() function\n              try {\n                // Standard\n                if (global.DOMParser) {\n                  response = new DOMParser().parseFromString(xhr.responseText, 'text/xml');\n                } // IE<9\n                else {\n                    response = new ActiveXObject('Microsoft.XMLDOM');\n                    response.async = 'false';\n                    response.loadXML(xhr.responseText);\n                  }\n              } catch (e) {\n                response = undefined;\n              }\n\n              if (!response || !response.documentElement || response.getElementsByTagName('parsererror').length) {\n                throw 'Invalid XML';\n              }\n\n              break;\n\n            default:\n              response = xhr.responseText;\n          }\n        } // Late status code verification to allow passing data when, per example, a 409 is returned\n        // --- https://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n\n\n        if ('status' in xhr && !/^2|1223/.test(xhr.status)) {\n          throw xhr.status + ' (' + xhr.statusText + ')';\n        } // Fulfilled\n\n\n        promise(true, [xhr, response]);\n      } catch (e) {\n        // Rejected\n        promise(false, [e, xhr, response]);\n      }\n    },\n        // Handle errors\n    handleError = function handleError(message) {\n      if (!aborted) {\n        message = typeof message == 'string' ? message : 'Connection aborted';\n        promise.abort();\n        promise(false, [new Error(message), xhr, null]);\n      }\n    },\n        // Handle timeouts\n    handleTimeout = function handleTimeout() {\n      if (!aborted) {\n        if (!options.attempts || ++attempts != options.attempts) {\n          xhr.abort();\n          sending = false;\n          promise.send();\n        } else {\n          handleError('Timeout (' + url + ')');\n        }\n      }\n    }; // Normalize options\n\n\n    options.async = 'async' in options ? !!options.async : true;\n    options.cache = 'cache' in options ? !!options.cache : false;\n    options.dataType = 'dataType' in options ? options.dataType.toLowerCase() : defaultDataType;\n    options.responseType = 'responseType' in options ? options.responseType.toLowerCase() : 'auto';\n    options.user = options.user || '';\n    options.password = options.password || '';\n    options.withCredentials = !!options.withCredentials;\n    options.timeout = 'timeout' in options ? parseInt(options.timeout, 10) : 30000;\n    options.attempts = 'attempts' in options ? parseInt(options.attempts, 10) : 1; // Guess if we're dealing with a cross-origin request\n\n    i = url.match(/\\/\\/(.+?)\\//);\n    crossOrigin = i && (i[1] ? i[1] != location.host : false); // Prepare data\n\n    if ('ArrayBuffer' in global && data instanceof ArrayBuffer) {\n      options.dataType = 'arraybuffer';\n    } else if ('Blob' in global && data instanceof Blob) {\n      options.dataType = 'blob';\n    } else if ('Document' in global && data instanceof Document) {\n      options.dataType = 'document';\n    } else if ('FormData' in global && data instanceof FormData) {\n      options.dataType = 'formdata';\n    }\n\n    if (data !== null) {\n      switch (options.dataType) {\n        case 'json':\n          data = JSON.stringify(data);\n          break;\n\n        case 'post':\n        case 'queryString':\n          data = jparam(data);\n      }\n    } // Prepare headers\n\n\n    if (options.headers) {\n      var format = function format(match, p1, p2) {\n        return p1 + p2.toUpperCase();\n      };\n\n      for (i in options.headers) {\n        headers[i.replace(/(^|-)([^-])/g, format)] = options.headers[i];\n      }\n    }\n\n    if (!('Content-Type' in headers) && method != 'GET') {\n      if (options.dataType in mimeTypes) {\n        if (mimeTypes[options.dataType]) {\n          headers['Content-Type'] = mimeTypes[options.dataType];\n        }\n      }\n    }\n\n    if (!headers.Accept) {\n      headers.Accept = options.responseType in accept ? accept[options.responseType] : '*/*';\n    }\n\n    if (!crossOrigin && !('X-Requested-With' in headers)) {\n      // (that header breaks in legacy browsers with CORS)\n      headers['X-Requested-With'] = 'XMLHttpRequest';\n    }\n\n    if (!options.cache && !('Cache-Control' in headers)) {\n      headers['Cache-Control'] = 'no-cache';\n    } // Prepare URL\n\n\n    if ((method == 'GET' || options.dataType == 'queryString') && data && typeof data == 'string') {\n      url += (/\\?/.test(url) ? '&' : '?') + data;\n    } // Start the request\n\n\n    if (options.async) {\n      promise.send();\n    } // Return promise\n\n\n    return promise;\n  }; // Define external qwest object\n\n\n  var getNewPromise = function getNewPromise(q) {\n    // Prepare\n    var promises = [],\n        loading = 0,\n        values = []; // Create a new promise to handle all requests\n\n    return pinkyswear(function (pinky) {\n      // Basic request method\n      var method_index = -1,\n          createMethod = function createMethod(method) {\n        return function (url, data, options, before) {\n          var index = ++method_index;\n          ++loading;\n          promises.push(qwest(method, pinky.base + url, data, options, before).then(function (xhr, response) {\n            values[index] = arguments;\n\n            if (! --loading) {\n              pinky(true, values.length == 1 ? values[0] : [values]);\n            }\n          }, function () {\n            pinky(false, arguments);\n          }));\n          return pinky;\n        };\n      }; // Define external API\n\n\n      pinky.get = createMethod('GET');\n      pinky.post = createMethod('POST');\n      pinky.put = createMethod('PUT');\n      pinky['delete'] = createMethod('DELETE');\n\n      pinky['catch'] = function (f) {\n        return pinky.then(null, f);\n      };\n\n      pinky.complete = function (f) {\n        var func = function func() {\n          f(); // otherwise arguments will be passed to the callback\n        };\n\n        return pinky.then(func, func);\n      };\n\n      pinky.map = function (type, url, data, options, before) {\n        return createMethod(type.toUpperCase()).call(this, url, data, options, before);\n      }; // Populate methods from external object\n\n\n      for (var prop in q) {\n        if (!(prop in pinky)) {\n          pinky[prop] = q[prop];\n        }\n      } // Set last methods\n\n\n      pinky.send = function () {\n        for (var i = 0, j = promises.length; i < j; ++i) {\n          promises[i].send();\n        }\n\n        return pinky;\n      };\n\n      pinky.abort = function () {\n        for (var i = 0, j = promises.length; i < j; ++i) {\n          promises[i].abort();\n        }\n\n        return pinky;\n      };\n\n      return pinky;\n    });\n  },\n      q = {\n    base: '',\n    get: function get() {\n      return getNewPromise(q).get.apply(this, arguments);\n    },\n    post: function post() {\n      return getNewPromise(q).post.apply(this, arguments);\n    },\n    put: function put() {\n      return getNewPromise(q).put.apply(this, arguments);\n    },\n    'delete': function _delete() {\n      return getNewPromise(q)['delete'].apply(this, arguments);\n    },\n    map: function map() {\n      return getNewPromise(q).map.apply(this, arguments);\n    },\n    xhr2: xhr2,\n    limit: function limit(by) {\n      _limit = by;\n      return q;\n    },\n    setDefaultOptions: function setDefaultOptions(options) {\n      defaultOptions = options;\n      return q;\n    },\n    setDefaultXdrResponseType: function setDefaultXdrResponseType(type) {\n      defaultXdrResponseType = type.toLowerCase();\n      return q;\n    },\n    setDefaultDataType: function setDefaultDataType(type) {\n      defaultDataType = type.toLowerCase();\n      return q;\n    },\n    getOpenRequests: function getOpenRequests() {\n      return requests;\n    }\n  };\n\n  return q;\n}();","map":null,"metadata":{},"sourceType":"script"}